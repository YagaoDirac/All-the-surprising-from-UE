蓝图转c++

这个文档假设你已经足够了解虚幻的编辑器内的功能，至少可以很熟练的写蓝图。
这个系列的另外一个文档 All the surprising from UE 是这篇文章的前置条件，请先阅读里面的c++相关的部分。我以后有可能会把这一块单独拿出来，灵活点。或者你想先跳过也可以。

反正只有鬼知道的各种原因，需要把蓝图上的东西抬到c++里面去。
顺便说一个细节，其实很多人觉得自己可以随手写蓝图了，觉得自己已经是很有经验的虚幻程序员了，但是其实这个是技术策划的技能。这个观点不是要吵架，只是希望大家知道，如果你的电脑不能轻松跑虚幻加一个vs，比如今天（2022），如果你的电脑没有32g内存，那么几乎可以肯定你没有足够的虚幻c++的能力。或者换句话说，如果你的电脑没有32g内存，你可以先不读这个文档了，或者读着玩，因为暂时没办法真的使用。



ok，正文开始：

几个细节。如果是vs2022，可以把live coding关了。editor preference里面。就用vs的build。
总的来说，虚幻很喜欢崩溃，所以所有地方都要做安全设计，反正就是一路if就完事了，不然重新开编辑器很浪费时间。所以m2的ssd，很大的cpu，还是很重要的。

现在只知道怎么蓝图到c++，不清楚其他的，比如什么行为树里面那些。
对着蓝图节点右键，go to definition，然后vs里面会自动定位。通常来说，这个函数就是要用的函数了，无论他是k2版本还是什么别的版本。
此外你还需要做一个事情，就是找到这个函数的定义，也就是header里面的那一句。你可以利用的有vs的类视图（注意不要换搜索面板搞混了），另外就是虚幻的代码的拜访还是比较规则的，从文件浏览器里面去找应该也很快。找到这个主要是要看它的UFUNCTION，里面确认清楚所有的东西的含义。我已知的一个很重要的是meta里面有一个什么什么worldcontext，然后这种情况一般第一个形参是一个UObject*，这个地方就是要穿当前的world进去。蓝图里面应该是自动解决了，但是c++里面就只有手动。这个world context通常可以直接利用AActor::GetWorld()直接得到。有一些函数还会额外的增加一个什么什么context的形参给蓝图，可以利用c++代码来确认其中的关系。此外就是记住，controller是从actor继承出来的，所以也可以得到这个函数。如果get world出来的是空，那你可能需要等一下，利用delay。


Delay的做法在网上有，总的来说，个人不推荐lambda expression，也可能是可行的。在类里面另外写一个函数，然后命名上面稍微注意一点。反正我的习惯是 OriginFunctionName_DelayCB_1，然后2，3。这样的好处是写法会比较连贯。vs会提醒，要用&在函数名字前面来得到函数的指针，我总觉得这个是c++的一个bug，反正能用就完事了。然后这个情景下，要用形参里面有this的版本。不用关心函数的那个具体类型，void进void出肯定是可以用的（所以写成类的成员函数比较方便。

ai move to应该是一个蓝图的宏，然后c++里面，网上也说了，是simple 什么什么，然后可能要自己手动处理后续的部分。





