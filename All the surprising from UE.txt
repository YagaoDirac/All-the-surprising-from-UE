虚幻的惊喜

最后更新2022，aug，14
https://github.com/YagaoDirac/All-the-surprising-from-UE

作者：yagaodirac
github：yagaodirac
twitter：yagaodirac



docs

官方有一些，按主题的，很不错。
mathew 的 wtf 系列
docs.unrealengine.com
learn.unrealengine.com
官方youtube，包括live training系列。
ue4community.wiki
UE4 - Blueprints to C++系列，yt上。这个系列的作者说的rider for unreal比vs明显更好，他在用。反正你们参考一下。



setup

官方文档里面有一个how to set up visual studio for unreal engine。现在的安装和以前好像不一样了。反正照做就完事了。

Visual Assist或者resharper。我现在还不清楚这个到底是怎么一回事，就看到的信息来说，va好像比较流行。可能这个信息是这个文档最最重要的一个。
用va的话，不要关vs自带的intellisense。
尝试尽量管掉虚幻里面的plugin。如果关错了，可以用记事本开虚幻的工程文件，找plugin browser一类的一个名字，写成true，就行了。
va的选项里面有针对虚幻的设置，一定要开。然后就是检测虚幻的插件，可以无脑的关，因为如果去虚幻里面关插件其实更麻烦。

安装的时候尽量在默认分区直接来，默认设置安装，安装以后不要移动任何文件，不然会出各种奇怪的bug。

除了vs加va的组合，还有rider for unreal。



c++

关于虚幻宏，就是UPROPERTY那些，在文档里面的Programming and Scripting, Gameplay Architecture.
虚幻宏里面用到的有几个，https://www.youtube.com/watch?v=TNSb6TJrl4U&list=PLY9cHlxw3OgjKmwaTEekW3sr_oHY-HwGv&index=5
里面讲了，但是我还是重复一下。blueprint readonly和readwrite，是在蓝图里面能不能得到set。edit，visible，这个是只能看和可以编辑，后面的default，instance，是指，蓝图里面的variable default，和，外面的level里面的instance的参数。
然后还有一个超级无敌重要的，meta里面的display name。如果看到这个了，一定要留意，这个带来无数的惊喜，非常的恶心。

live reload: 编辑器里面，editor setting，General，Live Coding，然后在vs里面是ctrl alt f11.
在vs里面，配置上选第二个，应该是development editor，然后点开始测试，就会自己开一个编辑器，可以下断点看编辑器里面是在干嘛。

继承的关系。比如本来是AActor，然后直接套蓝图，现在需要在中间写一个c++类，那么这个c++类是从AActor继承，然后新的蓝图是套在新的c++类上，也就是说，手写的c++的继承层级是在本来的空白逻辑的基类和蓝图类之间。在behavior tree上给节点写c++版本的时候，要从这些节点能继承的类上继承c++类，不要从c++类层级里面去猜。

c++里面的函数和蓝图里面的函数的名字很不一样，基本上只有最常规的几个是一致的，其他都不一致。如果发现下断点了都得不到，要看看虚幻自带的可以用的那些里面是怎么写的，尤其是callback是哪几个。



shipping，packaging，release，cooking

如果安装文件被移动过，会遇到无法cook的问题。最简单的办法就是重新安装虚幻。
此外，查到的一些细节：
editor preferences里面：
enable support for long paths(260什么），可以无脑勾上。
project settings里面：
最上面的project里面，好几个都和发布有关。其中，project，packaging，右边packaging里面，advanced，list of maps to inlucde in a pachaged build，这个里面选文件的时候是选.umap文件。

project，platforms，里面，是其他的化妆。

cooking的一些具体细节可以在
https://docs.unrealengine.com/5.0/en-US/build-operations-cooking-packaging-deploying-and-running-projects-in-unreal-engine/
找到。我暂时不研究这个了。



碰撞检测，物理

模拟物理有一个单独的check box。
开模拟物理以后，碰撞组的那个地方必须要选择enable physics的其中一个，不然会出warning。
query是sweep，overlap，各种trace by channel用的。必须也要在droplist里面选开启query。
overlap 事件必须是双方都要generates 才有。
hit struct里面的impact normal很可能是算法真的找到的第一个三角面，测试过，不是很稳定，不是最靠近或者最什么什么角度的。如果相邻三角面的角度不大，应该还ok。反正正常情况用normal就很好。除非normal在撞到边和角的时候会比较破碎。

physical anim里面，mesh的碰撞要把模拟物理开开，不然不会有效果。
手动追加物理干扰的方法有，appulse，add force，set linear/angular velocity。

遇到碰撞或者overlap不工作的情况，依次检查所有的可能的地方。函数里面通常由忽略自己，忽略列表，到底是by channel还是by object type。所有相关物体的模拟物理开了没，函数里面也可以设置模拟物理。然后detail面板里面的collision里面的那个droplist里面有没有物理，下面的3列的check box里面设置对没有。
比较容易忘记的还是函数调用的时候的各种设置。



bsp

5里面是在quick add to project（cube with a green +）里面的place actor panel。然后进去找。
之后在details里面，有一个align brush vertices，点一下，不然编辑功能不全。
lethe是要用2d的图形。做法是，最坐上的select mode，然后（省略），然后pen模式，勾上create brush shape，然后在轴对齐的某一个视图画，然后lethe工具，在另外一个轴对齐视图用。
选中有相互作用的所有bsp，一起转static mesh，不然会抽。
bsp增加三角面的时候，点选顶点的时候要顺时针，不然flip。



controller/ AI controller

单机不要在主角上用possess。
AI controller的auto possess一定要写对。spawn的和placed的一定要写对，不然会没有。
推荐在ai controller里面从on possess开始写，而不是begin play开始。



behavior tree

写在行为树的笔记的最开头，service，task那些里面，如果无法正常的得到黑板的内容，用传进来的controller，cast，get blackboard，然后往外拿。这些函数也会得到pawn，所以其实这些变量不一定要保存的黑板上。黑板的目的可能只在于行为树内部的事件驱动，也就是虚幻内建在行为树里面的那些decorator和task，和类似的。如果不是给内建的那些东西用，variable放在黑板上和放在controller或者pawn上没有任何区别。

行为树的3个可自定义的组件的核心内容：
task里面是perform condition check AI, execution start AI, execution finish AI.
decorator: 
service: 

c++里面写行为树的node，新建之后直接编译是通不过的，这个时候从报错里面，找到有一个函数未定义，复制出来，然后随便定义一下，再编译，就可以了。

BTNode好像是无法保存自身的变量的，所有用同一个行为树的都共享这些节点，官方文档里面提到一个变量叫bCreateNodeInstance，我没查到，应该是c++里面的。总之官方提供了2个黑板之外的存变量的方法。
https://docs.unrealengine.com/4.26/en-US/InteractiveExperiences/ArtificialIntelligence/BehaviorTrees/BehaviorTreeNodeReference/
的最后。

simple paralell。immediate模式下，task返回，就结束。delay模式下，task返回了，再等右边下一次结束的时候才结束。simple paralell的设计意图和平行没有任何关系，左边的task应该就是一个简单的门，右边的子树才是干活的部分。simple paralell的一个无法替代的能力是，task不返回的情况下，右边的子树可以执行任意次，而完全无视外面的更高优先级的部分。

task节点里面abort好像是没有效果的，必须是finish才能结束。得到的callback只有execute和tick。不排除abort要配合simple paralell。




虚幻的行为树和标准行为树的区别：

刚刚看到的，还没测试的。task里面可以有set finish on message。也是可以做消息驱动的。


1，虚幻的行为树没有标准的平行节点
2，重复不是用decorator做，而是用simple paralell做，如上面一段的描述。

一个子树的反复执行：
1，decorator里面有好几个内建的，conditional loop, loop, time limit。
2，利用simple parallel, 有一个单独的task，利用这个task来控制另外一边的子树的提前结束，simple parallel本身要设置为immediate。注意，不能反过来，右边的子树不能控制左边的task的提前结束。另外一个用法就是，task结束时间比右边的子树要晚，右边的子树会反复执行。这应该是唯一的反复执行一个子树而不执行优先级更高的（外面的左边）的部分的方法。

一个子树的提前结束
，在子树根节点放一个decorator（blackboard），利用这个decorator的abort。（还没测试）
2，如同上面的2，利用simple parallel

if逻辑的方法：
1，官方推荐的是用decorator
2，根节点用sequence，在里面，前面的task根据条件返回success或者failure，真的task放后面。但是根据官方的推荐，task只做真的任务，不做条件，所以这个做法要斟酌一下。不过在标准的行为树里面，这个做法是存在的。

并行的方法：
官方推荐的是用service。利用service，路径上的所有service都是一起执行的。可以把永远要执行的放在尽量靠近整个树的根的位置。
另外一个我个人不推荐的做法，simple parallel只能把一个task和一个子树并行起来，如果嵌套一个simple parallel，也只有2个task和1个子树，而且会导致退出时机的问题，感觉应该是很不好用的。

利用abort low priority的特性，加上多层selector或者多层sequence，可以限制abort的范围，从而不一定要在每个节点上加decorator来abort self。

状态机转行为树：
用一个变量标记一下现在是什么状态，然后用decorator来判断，如果是，就放进去，如果不是就跳过。这样就可以形成一个多层的状态机。好像有点笨。



black board

一个巨大的惊喜，没有数组。要用的话，自定义一个blueprint。
官方在2015年的时候说过很快就会实现，反正今天2022年，写这个文档的时候，没有。



nav mesh, navmesh

navmesh本身内容不多，官方文档不长。需要记住的事情主要是：
1，好像没有办法在同一个level里面制作超过1个navmesh，所以可能要为了多重navmesh专门制作多个level。另外一个可能可以的思路是，在project setting里面，navmesh里面，好像可以找到给不同的agent的设置，但是总觉得就算能用也会很局限。
2，navmesh可以让pawn跳，文档里面有讲。
3，可以设置动态的navmesh，不过好像没什么用。动态下不知道能不能设置代价，没测试。
4，ai在navmesh里面移动，在蓝图里面的节点是AI Move To，不是常规的函数节点，更像是一个宏，右上角有时钟图标。
5, https://forums.unrealengine.com/t/how-do-i-get-the-navigation-path-to-a-point/294257/4



reinforcement learning

暂时没时间确认这一块了。
有一个插件叫mindmaker，中间没有空格。这个是专门的rl的。没测试过，不过可能需要足够的rl的基本功才有办法用。
虚幻本身还有一个nni，neural network interface。但是这个应该没有专门的rl的框架。
5里面好像还有一个官方提供的unreal engine support for machine learning.



math expression

如果用到某个变量，名字没有空格，会在里面直接取得，不用连线。鼠标指到这个math expression节点，可以双击进去，官方文档说的是类似一个子蓝图。
其他就是，vec（1，2，3）这个语法是存在的，包括rotator，transform，以及他们的别名，缩写。
缩写是ok的。
反正很不规范的一个特性。文档不长。https://docs.unrealengine.com/4.26/en-US/ProgrammingAndScripting/Blueprints/UserGuide/MathNode/



event

蓝图里面的时候details里面有一个好像是consume event。这个会导致独占，但是可能不稳定。

event还有一个顺序问题。我不记得官方的图在哪儿了，反正就是，
1，有设置enable input的所有的actor
2，controller。controller还可以设置一个好像是叫prerequisite tick actor，我没测试，反正名字大概也很好理解。
3，ui还是gamemode，忘了，好像是gamemode吧。
4，pawn
这个顺序可以帮助解决输入事件拦截的一些很诡异的问题。



reset level

会调用on reset level。
编辑器里面根据浏览的视觉位置自动创建的character会被删，也就是说这个功能和编辑器里面的调试功能会有一些冲突，不过也无所谓，正式的版本多半不依赖这个。



widget, umg, ui

1，widget是无法删除的，无法destroy的。如果作为根，要用add to viewport，其他的是add child widget。去掉的时候，根是remove from parent，其他的可以remove from parent，可以remove child，调用的主object不同。

2，anchor，也就是那朵菊花，逻辑是，菊花只标记百分比，之后子物件的具体的4个边是根据到菊花的绝对距离。
比如一个一维的例子：
anchor是10%到50%，子物件从anchor开始的偏移是12和-21。
如果上一级widget是从100到500，那么anchor就是从100+（（500-100）*10%） == 140，到100+（（500-100）*50%） == 300。然后子物件的位置是从140+12开始，到300-21结束。如果设置不合理，有可能出现结束比开始的坐标还小，结果应该是无法显示。
换句话说，如果一个子物件要完全根据上一级物件的缩放而缩放，那么应该偏移设置为0，那么anchor的具体位置也就是子物件的实际的4个角。在编辑器里面设置的时候，先把菊花的位置放好，然后把4个offset全部写成0。
测试的时候的一个技巧，编辑器的主视口的右上，最后一个按钮是控制整个widget的尺寸的，进去第二个是custom，然后这个时候最大的那个框就可以调节了。

3，hierarchy面板里面，对着任何一个点右键，有wrap with 和replace with。外面加东西是wrap with，去掉自己是replace with然后进去选child.

4，细节面板最上面，is variable。

5，如果一个子物件的最大尺寸不正确，外面包裹的是canvas，多半是canvas的offset不是0.

6，如果一个子物件没有尺寸，又需要控制它的尺寸，可以利用的东西是，在旁边放一个spacer，或者在外面套一个sizer或者border。我遇到过的一个情况是，最简单的那个text是不会占据一个尺寸的，在旁边放一个spacer帮它撑住那个空间，防止多个text重叠。这个技巧在vertical box和horizontal box里面有一些奇怪的东西的时候可能会见奇效。

c++里面写ui是一个重灾区，各种乱七八糟的东西。
c++里面写的时候，在header里面无脑的include一下blueprint/widgettree.h，除非知道确实不用这个。widgettree是物体，不是namespace或者class definition。
c++里面的函数是native开头的，nativexxx这种。没有UFUNCTION标记。
meta = (BindWidget)，还是WidgetBind，忘了。



Gameplay Tag system

这是一个plugin。
这个和actor的detail里面自带的那个tag是不同的。只能选择在引擎里面注册过的tag，而ue自带的tag是任意的字符串。
在actor里面新建变量，设置为gameplay tag或者gameplay tag container。
tag的检查方法基本是以match开头的，cont的检测方法基本是以has开头的。
有一个expression系统，但是官方给的例子是检测出来以后，结果是bool，再手动处理。效果来说应该是一样的。可以不理那个expression的做法。
所有的比较都有一个source和input的区别，source如果是a.b，那么implicitly自带一个a（除非是exact版本），而input没有这个说法。source永远在前面。input永远在后面，而好像只可能是一个cont。cont可以和array无缝衔接，所以感觉整个系统就是一个糖。
proj setting里面，有一个restricted config file，反正就是一个团队协作相关的权限控制的东西。里面的config name好像只能是*.ini，就是说必须是一个文件名。而这个文件还不能是config文件夹下的那个ini，还必须是config/tag里面的ini。
没有找到category remapping的任何资料，测试了一下也没有任何结果。
Gameplay tag redirects是一个很危险的东西，一定要小心。它的效果是把编辑器里面的所有的tag进行转换，比如设置a转换成b，那么运行的时候，所有的a就变成了b，好像没有办法取消。我猜这个东西的用法应该是在一个模块测试的时候，用这个转，然后用完马上回来把这个里面的东西清空。如果设置a变b，b变c，a会直接变成c。反正出问题就gg了，能不用尽量不要用。
4里面好像不能在proj setting里面做任何的修改，5好像才可以。所以前面说的那个没有测试出来的东西，可能以后用5的时候才会知道是什么。


Camera Modifier

新建蓝图以后，找到functions，在overload里面，只有2个。其中有一个，输出需要一个结构体，make以后这个结构体的情况比较特殊，要在details里面勾选，相关的选项才会出现。
用的方法是，player controller，里面的，player camera manager, 然后设置。


K2（不推荐用这个）

网上有制作K2版本的函数的资料，但是不推荐真的在项目里面用。
K2据说是以前虚幻很早的版本里面的kismet2.0，它的接班人是蓝图。通常的说法是k2开头的函数是蓝图里面调用的时候所调用的版本，在c++里面不用碰他们。这一块资料非常少。AddActorWorldOffset就是其中一个。









